<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js â€“ The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>The architecture of Dotty</h1>
					<h3>A next-generation Scala compiler</h3>
					<p>
					  <small><a href="http://guillaume.martres.me">Guillaume Martres</a> - EPFL</small>
                      <br>
                      <ul>
                        <li>These slides are two-dimensional, the left and right arrow keys will skip over vertical slides</li>
                        <li>The space key will always go to the next slide</li>
                      </ul<
					</p>
				</section>

				<section>
				  <h2>Note well</h2>
                  <ul>
                    <li>To avoid overloading you with information, this presentation omits or present a simplified version of many things</li>
                    <li>The goal is to get you to understand the concepts we used so that you may reuse them in a completely different project, rather than to turn you into an expert on Dotty itself</li>
                    <li>See the <a href="https://github.com/lampepfl/dotty/wiki/Getting-Started#talks-on-dotty">other talks on Dotty</a> if you're interested!</li>
                  </ul>
                </section>

				<section>
					<h2>Dotty</h2>
					<ul>
                      <li>Started by Martin Odersky in 2013</li>
                      <li>Bootstrapped (compiler can compile itself) in October 2015</li>
                      <li>A new architecture
                        <ul><li>Except for the backend (bytecode generator) which is mostly shared with Scala 2.12</li></ul>
                      </li>
                      <li>First goal: Simplify the internals of the type system</li>
                      <li>Couple of years from being production-ready</li>
                    </ul>
                </section>

				<section>
				  <h2>Trees, Types and Symbols</h2>
                  <ul>
                    <li>The compiler represents code using <font color="#FF4136">trees</font></li>
                    <li>To ensure type-safety, we attach <font color="#FF4136">types</font> to trees</li>
                    <li>A tree might refer to an identifier defined in another
                      tree or in the classpath, to each valid identifier
                      corresponds a <font color="#FF4136">symbol</font> looked
                      up in the symbol table for the current scope, a symbol has a type
                    <li>Each phase of the compiler pipeline simplifies trees and types
                      until they can be easily expressed using Java bytecode</li>
                    <li>All of these data structures are immutable (or look immutable but use caching under the hood)</li>
                  </ul>
                </section>

				<section>
				  <h2>The compiler pipeline</h2>
                  <img src="images/phases.png">
                </section>

                <section>
				<section>
				  <h2>Part 1: Frontend</h2>
                  <h3>Generating trees and typing them</h3>
                </section>

				<!-- <section> -->
				<!--   <h2>Untyped Tree</h2> -->
                <!--   <p> -->
                <!--     <pre><font color="#FF4136">val foo: <font color="#FF851B">String</font> = <font color="#2ECC40"><font color="#0074D9">obj</font>.fun(<font color="#FFDC00">5</font>)</font></font></pre> -->
                <!--     <pre class="fragment"><font color="#FF4136">ValDef("foo", <font color="#FF851B">Ident("String")</font>, <font color="#2ECC40">Apply(<font color="#0074D9">Ident(obj)</font>, "fun", <font color="#FFDC00">Literal(5)</font>)</font>)</font></pre> -->
                <!--   </p> -->
                <!-- </section> -->
				<section>
				  <h2>Untyped Tree</h2>
                  <p>
                    <!-- <pre><font color="#FF4136"><font color="FFDC00"><font color="#0074D9">obj</font>.fun</font>(<font color="#2ECC40">5</font>)</font></pre> -->
                    <!-- <pre><font color="#FF4136">Apply(<font color="#FFDC00">Select(<font color="#0074D9">Ident("obj")</font>, "fun")</font>, <font color="#2ECC40">Literal(5)</font>)</font></pre> -->
                    <pre>obj.fun(5)</pre>
                    <pre><font color="#0074D9" class="fragment" data-fragment-index="1">obj</font><font color="#FFDC00" class="fragment" data-fragment-index="2">.fun</font><font color="#FF4136" class="fragment" data-fragment-index="3">(</font><font color="#2ECC40" class="fragment" data-fragment-index="4">5</font><font color="#FF4136" class="fragment" data-fragment-index="3">)</font></pre>
                    <pre><font color="#FF4136" class="fragment" data-fragment-index="3">Apply(</font><font color="#FFDC00" class="fragment" data-fragment-index="2">Select(</font><font color="#0074D9" class="fragment" data-fragment-index="1">Ident("obj")</font><font color="#FFDC00" class="fragment" data-fragment-index="2">, "fun")</font><font color="#FF4136" class="fragment" data-fragment-index="3">, </font><font color="#2ECC40" class="fragment" data-fragment-index="4">Literal(5)</font><font color="#FF4136" class="fragment" data-fragment-index="3">)</font></pre>
                  </p>
                </section>

                <section data-markdown>
                  <script type="text/template">
                    ## Scala's typing algorithm (heavily simplified)

                    - Recursively type subtrees, remembering the expected type
                    - <!-- .element: class="fragment" --> type `obj.fun(5)` with expected type `?`
                      - <!-- .element: class="fragment" --> type `obj.fun` with expected type `? => ?`
                        - <!-- .element: class="fragment" --> type `obj` with expected type `{ fun: ? => ? }`
                    - <!-- .element: class="fragment" --> Expected type used to:
                      - Infer type parameters
                      - Adapt type in some cases (implicit conversions, ...)
</script>
                </section>

				<section data-transition="fade-out">
				  <h2>Typed tree, first attempt</h2>
                  <pre><code class="scala" data-trim data-noescape>
<span class="fragment">class A {
  def fun(x: Int): Int = x
}
val obj: A = new A</span>
obj.fun(5)
                  </code></pre>
                  <div data-markdown>
                    <script type="text/template">
                      - <!-- .element: class="fragment" --> Rely on the type of symbols
                      - <!-- .element: class="fragment" --> `obj` gets type `A`
                      - <!-- .element: class="fragment" --> `obj.fun` gets type `Int => Int`
                      - <!-- .element: class="fragment" --> `obj.fun(5)`  gets type `Int`
                    </script>
                  </div>
				  <aside class="notes">
                    But type of `obj`, and thus type of `obj.fun` might change, trees are immutable for many
                    good reasons (easier to reason, time-travel, multi-threading), try to avoid COW

				  </aside>
                </section>

				<section data-transition="fade-in">
				  <h2>Typed tree, first attempt fails</h2>
                  <pre style="background-color: #3F3F3F; padding: 5px;" data-trim data-noescape>
<font color="#E0CBA9">class</font> <font color="#EFEF8F">A</font><font color="#FF4136">[T]</font> {
  <font color="#E0CBA9">def</font> <font color="#EFEF8F">fun</font>(x: <font color="#FF4136">T</font>): <font color="#FF4136">T</font> = x
}
<font color="#E0CBA9">val</font> obj: <font color="#EFEF8F">A</font><font color="#FF4136">[Int]</font> = <font color="#E0CBA9">new</font> <font color="#EFEF8F">A</font><font color="#FF4136">[Int]</font>
obj.fun(<font color="#6B9294">5</font>)</pre>
                  <div data-markdown>
                    <script type="text/template">
                      - <!-- .element: class="fragment" --> Rely on the type of symbols
                      - <!-- .element: class="fragment" --> `obj` gets type `A[Int]`
                      - <!-- .element: class="fragment" --> `obj.fun` gets type `T => T`
                        - <!-- .element: class="fragment" --> This is wrong, it should be `Int => Int`
                    </script>
                  </div>
                </section>

				<section>
				  <h2>References to types</h2>
                  <ul>
                    <li>Symbols do not capture enough information
                      <ul>
                        <li>in an OO language with a rich type system, the <b>prefix</b> used to access an identifier matters</li>
                      </ul>
                    </li>
                    <li>Let us introduce a special kind of type which refers to another type:
                      <pre><code class="scala">class TermRef(prefix: Type, name: String) extends Type</code></pre></li>
                    <li><font face="monospace">obj.fun</font> gets type <font face="monospace">TermRef(x, "fun")</font> which refers to the type <font face="monospace">Int => Int</font></li>
                  </ul>
                </section>

				<section>
				  <h2>The story so far</h2>
                  <img src="images/den1.png" style="background:none; border:none; box-shadow:none;">
                </section>

				<section>
				  <h2>Denotation: linked list of lazily computed types</h2>
                  <img src="images/den2.png" style="background:none; border:none; box-shadow:none;">
                </section>

				<section>
				  <h2>More accurate picture</h2>
                  <img src="images/den3.png" style="background:none; border:none; box-shadow:none;">
                </section>

                </section>
                <section>
				<section>
				  <h2>Part 2: Middle-End</h2>
                  <h3>Simplifing types and trees with successive transformations</h3>
                </section>

                <section data-markdown>
                  <script type="text/template">
                    ## Transformation example: ElimRepeated

                    - Type transformation: `T*` becomes `Seq[T]`
                    - Tree transformation: `foo("one", "two")` becomes `foo(Seq("one", "two"))`
                  </script>
                </section>

				<section>
				  <h2>Common pattern for transforming trees</h2>
                  <pre><code class="scala" data-trim>
override def transform(tree: Tree): Tree = {
  // call "transform" on every node that tree points to
  val tree1 = transformChildren(tree) 

  tree1 match {
    case tree: Apply =>
      // make a new tree and return it
      ...
    case tree: Select =>
      // make a new tree and return it
      ...
    case tree => // default case
      tree1
  }
}
</code></pre>
                </section>

				<section>
				  <h2>Simplified API for common case</h2>
                  <pre><code class="scala" data-trim>
// Precondition of each transformX method: children nodes
// are already transformed by this phase
override def transformApply(tree: Apply): Tree = {
  // make a new tree and return it
  ...
}
override def transformSelect(tree: Select): Tree = {
  // make a new tree and return it
  ...
}
// No need to override transformX if we do not need to
// transform them
</code></pre>
                </section>
                </section>
                <section>
				<section>
                  <h3>Traditional phase design</h3>
                  <h4>1 phase = 1 full traversal</h4>
                </section>
                <section data-transition="none-out">
				  <img src="images/mini1.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini2.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini3.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini4.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini5.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini6.png">
                </section>
                <section data-transition="none">
				  <img src="images/mini7.png">
                </section>
                </section>
                <section>
				<section>
                  <h3>Mini-phase design</h3>
                  <h4>N fused mini-phases = 1 full traversal</h4>
                </section>
                <section data-transition="none-out">
				  <img src="images/mini1.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib2.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib3.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib4.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib5.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib6.png">
                </section>
                <section data-transition="none">
				  <img src="images/minib7.png">
                </section>
                </section>
                <section>
				  <h2>References</h2>
                  <ul>
                    <li>Code: <a href="http://github.com/lampepfl/dotty">github.com/lampepfl/dotty</a></li>
                    <li>Other talks on Dotty on the <a href="https://github.com/lampepfl/dotty/wiki/Getting-Started#talks-on-dotty">GitHub Wiki</a></li>
                  </ul>
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
                    { src: 'socket.io/socket.io.js', async: true },
                    { src: 'plugin/notes-server/client.js', async: true }
				]
			});

		</script>

	</body>
</html>
